local OrionLib = loadstring(game:HttpGet("https://raw.githubusercontent.com/BlizTBr/scripts/refs/heads/main/Orion%20X"))()

-- Tema roxo personalizado
OrionLib.Themes.Purple_T = {
    Main     = Color3.fromRGB(10, 0, 15),
    Second   = Color3.fromRGB(25, 0, 35), 
    Stroke   = Color3.fromRGB(180, 100, 255),
    Divider  = Color3.fromRGB(120, 60, 200),
    Text     = Color3.fromRGB(220, 180, 255),
    TextDark = Color3.fromRGB(180, 140, 230)
}

OrionLib.SelectedTheme = "Purple_T"

-- Tabela de chaves válidas
local chavesValidas = {
    ["SoudHub"] = true,
    ["NiggaHub"] = true,
    ["E2fs01vnmisca"] = true
}

local premiumAtivo = false
local chaveInserida = ""

-- Cria janela principal
local Window = OrionLib:MakeWindow({
    Name = "Soud Hub PC",
    HidePremium = false,
    SaveConfig = true,
    ConfigFolder = "NiggaHubConfig",
    IntroEnabled = true,
    IntroText = "Nigger Loaded"
})

-- Variáveis necessárias
local plr = game.Players.LocalPlayer
local rs = game:GetService("ReplicatedStorage")
local uis = game:GetService("UserInputService")
local cam = workspace.CurrentCamera
local mouse = plr:GetMouse()
local inv = workspace:WaitForChild(plr.Name.."SpawnedInToys")
local currentHouseS = 0

-- Variáveis do Auto Gucci
local autoGucciT = false
local destroyAutoGucciT = true
local sitJumpT = false
local blobmanInstanceS = nil
local ragdollLoopD = false

-- Variáveis do Anti-Grab
local antiGrabT = false
local antiGrabAnchorT = true
local antiBlobT = false
local antiExplodeT = true

-- Variáveis para o sistema de teleporte
local teleportKeybind = Enum.KeyCode.T
local teleportConnection = nil

-- Variáveis para o sistema de inspeção
local inspectT = false
local inspectInfoT = false
local inspectInfoOnT = false
local currentInspectS = 0
local currentHouseInspectS = 0
local currentInspectedAdorneeS = nil
local currentInspectedPartS = nil
local inspectD = false
local highlightInstance = nil
local billboardInstance = nil

-- Variáveis para Player Tab
local walkSpeedT = false
local walkSpeedV = 16
local infJumpT = false
local jumpPowerV = 50
local infJumpD = false
local noClipT = false
local returnPosS = CFrame.new()

-- Variáveis para Player Selection
local selectedPlayer = nil
local teleportLoop = false
local bringLoop = false

-- Variáveis para Blobman Tab
local blobmanAutoFarm = false
local blobmanFarmSpeed = 1
local _G = {
    BlobmanDelay = 0.005,
    ToyToLoad = "BombMissile",
    MaxMissiles = 9
}

-- Variáveis para Anchor Grab
local anchorGrabEnabled = false
local anchoredParts = {}
local anchoredConnections = {}

-- Variáveis para Linhas (Sistema de Força)
local lineStrength = 400
local lineForceEnabled = false
local lineStrengthConnection = nil

-- Configurações para Linhas Tab
local Config = {
    throwStrength = 100,
    forceEnabled = false,
    slideHeight = 50,
    autoHeight = false,
    infiniteMode = false
}

-- Instâncias para inspeção
local highlight = Instance.new("Highlight")
highlight.Name = "highlight"
highlight.Enabled = true
highlight.FillTransparency = 0.9
highlight.OutlineTransparency = 0

local billboard = Instance.new("BillboardGui")
billboard.Name = "billboard"
billboard.Size = UDim2.new(0, 100, 0, 150)
billboard.StudsOffset = Vector3.new(0, 1, 0)
billboard.AlwaysOnTop = true

local scrollframe = Instance.new("ScrollingFrame")
scrollframe.Name = "scrollframe"
scrollframe.ScrollingEnabled = true
scrollframe.BackgroundTransparency = 0.7

local textlabel = Instance.new("TextLabel")
textlabel.Name = "textlabel"
textlabel.TextScaled = true
textlabel.BackgroundTransparency = 1

-- Variáveis do sistema Blobman do script fornecido
local blobalter = 1
local blobman = nil
local blobmanCoroutine = nil
local bombList = {}
local reloadBombCoroutine = nil
local connectionBombReload = nil

-- Funções para Linhas Tab (Sistema de Força Real)
local function aplicarForcaArremesso()
    OrionLib:MakeNotification({
        Name = "Força de Arremesso Ajustada",
        Content = "Força definida para: " .. lineStrength,
        Time = 3
    })
end

local function setupLineStrength()
    if lineStrengthConnection then
        lineStrengthConnection:Disconnect()
    end
    
    lineStrengthConnection = workspace.ChildAdded:Connect(function(model)
        if model.Name == "GrabParts" and lineForceEnabled then
            local partToImpulse = model.GrabPart.WeldConstraint.Part1
            if partToImpulse then
                local velocityObj = Instance.new("BodyVelocity", partToImpulse)
                model:GetPropertyChangedSignal("Parent"):Connect(function()
                    if not model.Parent then
                        if uis:GetLastInputType() == Enum.UserInputType.MouseButton2 then
                            velocityObj.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                            velocityObj.Velocity = workspace.CurrentCamera.CFrame.LookVector * lineStrength
                            game:GetService("Debris"):AddItem(velocityObj, 1)
                        else
                            velocityObj:Destroy()
                        end
                    end
                end)
            end
        end
    end)
end

local function ativarSistemaForca()
    lineForceEnabled = true
    setupLineStrength()
    OrionLib:MakeNotification({
        Name = "Sistema de Força Ativado",
        Content = "Sistema de força de arremesso ativado",
        Time = 3
    })
end

local function desativarSistemaForca()
    lineForceEnabled = false
    if lineStrengthConnection then
        lineStrengthConnection:Disconnect()
        lineStrengthConnection = nil
    end
    OrionLib:MakeNotification({
        Name = "Sistema de Força Desativado",
        Content = "Sistema de força de arremesso desativado",
        Time = 3
    })
end

-- Funções placeholders para as outras opções de Linhas
local function ajustarAlturaSlides()
    OrionLib:MakeNotification({
        Name = "Altura Ajustada",
        Content = "Altura dos slides ajustada para: " .. Config.slideHeight,
        Time = 3
    })
end

local function ativarAlturaAutomatica()
    OrionLib:MakeNotification({
        Name = "Altura Automática Ativada",
        Content = "Altura automática ativada",
        Time = 3
    })
end

local function ajustarModoInfinito()
    OrionLib:MakeNotification({
        Name = "Modo Infinito Ajustado",
        Content = "Modo infinito: " .. tostring(Config.infiniteMode),
        Time = 3
    })
end

local function aplicarEstiloFlexbox()
    OrionLib:MakeNotification({
        Name = "Estilo Flexbox Aplicado",
        Content = "Estilo flexbox aplicado com sucesso",
        Time = 3
    })
end

local function aplicarCorFundoSlides(color)
    OrionLib:MakeNotification({
        Name = "Cor de Fundo Alterada",
        Content = "Cor de fundo dos slides alterada",
        Time = 3
    })
end

local function resetarConfiguracoes()
    Config.throwStrength = 100
    Config.forceEnabled = false
    Config.slideHeight = 50
    Config.autoHeight = false
    Config.infiniteMode = false
    
    lineStrength = 400
    lineForceEnabled = false
    
    if lineStrengthConnection then
        lineStrengthConnection:Disconnect()
        lineStrengthConnection = nil
    end
    
    OrionLib:MakeNotification({
        Name = "Configurações Resetadas",
        Content = "Todas as configurações foram resetadas",
        Time = 3
    })
end

local function loadPremiumFeatures()
    OrionLib:MakeNotification({
        Name = "Recursos Premium Carregados",
        Content = "Aproveite os recursos premium!",
        Time = 3
    })
end

-- Função auxiliar table.find se não existir
if not table.find then
    table.find = function(t, value)
        for i, v in ipairs(t) do
            if v == value then
                return i
            end
        end
        return nil
    end
end

-- FUNÇÃO PARA LIMPAR INSPEÇÃO
local function clearInspection()
    if highlightInstance then
        highlightInstance:Destroy()
        highlightInstance = nil
    end
    
    if billboardInstance then
        billboardInstance:Destroy()
        billboardInstance = nil
    end
    
    currentInspectS = 0
    currentHouseInspectS = 0
    currentInspectedAdorneeS = nil
    currentInspectedPartS = nil
    inspectInfoOnT = false
end

-- FUNÇÃO DE TELEPORTE POR KEYBIND
local function setupTeleportKeybind()
    return uis.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        
        if input.KeyCode == teleportKeybind then
            local char = plr.Character
            if not char then return end
            local hrp = char:FindFirstChild("HumanoidRootPart")
            if not hrp then return end
            
            if mouse.Target then 
                hrp.CFrame = CFrame.new(mouse.Hit.X, mouse.Hit.Y + 5, mouse.Hit.Z)
            end
        end
    end)
end

-- FUNÇÕES PLAYER TAB
local function updateWalkSpeedF()
    local char = plr.Character
    if not char then return end
    local hum = char:FindFirstChild("Humanoid")
    if not hum then return end
    
    if walkSpeedT then
        hum.WalkSpeed = walkSpeedV
    else
        hum.WalkSpeed = 16
    end
    
    hum:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
        if walkSpeedT then
            hum.WalkSpeed = walkSpeedV
        else
            hum.WalkSpeed = 16
        end
    end)
end

local function updateJumpPowerF()
    local char = plr.Character
    if not char then return end
    local hum = char:FindFirstChild("Humanoid")
    if not hum then return end
    
    if infJumpT then
        hum.JumpPower = jumpPowerV
    else
        hum.JumpPower = 50
    end
end

local function updateNoClipF()
    local char = plr.Character
    if not char then return end
    
    while noClipT and task.wait(0.1) do
        for _, part in pairs(char:GetChildren()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
    end
    
    if not noClipT then
        for _, part in pairs(char:GetChildren()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
            end
        end
    end
end

local function updateInfJumpF()
    local char = plr.Character
    if not char then return end
    local hum = char:FindFirstChild("Humanoid")
    if not hum then return end
    
    uis.JumpRequest:Connect(function()
        if infJumpT and not infJumpD then
            infJumpD = true
            hum:ChangeState(Enum.HumanoidStateType.Jumping)
            task.wait()
            infJumpD = false
        end
    end)
end

-- FUNÇÃO DE INFINITE JUMP
local function setupInfiniteJump()
    uis.JumpRequest:Connect(function()
        if infJumpT and not infJumpD then
            infJumpD = true
            local hum = plr.Character and plr.Character:FindFirstChildOfClass("Humanoid")
            if hum then
                hum:ChangeState(Enum.HumanoidStateType.Jumping)
            end
            task.wait()
            infJumpD = false
        end
    end)
end

-- FUNÇÕES DE INSPEÇÃO
local function mouseTargetInspectF()
    local char = plr.Character
    if not char then return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    local hum = char:FindFirstChild("Humanoid")
    if not hrp or not hum then return end
    
    if mouse.Target then
        -- Verifica se já está inspecionando o mesmo objeto
        if currentInspectedAdorneeS and currentInspectedAdorneeS == mouse.Target.Parent then
            clearInspection()
            return true
        end
        
        -- Limpa inspeção anterior
        clearInspection()
        
        if mouse.Target.Parent:FindFirstChildOfClass("Humanoid") then
            currentInspectS = 1
            currentHouseInspectS = 0
        elseif mouse.Target.Parent:IsDescendantOf(workspace.Plots) then
            local current = mouse.Target
            repeat
                current = current.Parent
            until current == nil or string.match(current.Name, "Plot")
            
            if current then
                for i = 1, 5 do
                    if current.Name == "Plot"..i then
                        currentHouseInspectS = i
                    end
                end
                currentInspectS = 2
            end
        elseif mouse.Target.Parent:IsDescendantOf(workspace.PlotItems) or 
               (mouse.Target.Parent.Parent and string.match(mouse.Target.Parent.Parent.Name, "SpawnedInToys")) or 
               (mouse.Target.Parent.Parent and mouse.Target.Parent.Parent:FindFirstChild("SpawningPlatform")) then
            currentInspectS = 3
            currentHouseInspectS = 0
        else
            currentInspectS = 4
            currentHouseInspectS = 0
        end
        return false
    end
    return false
end

local function inspectF()
    local char = plr.Character
    if not char then return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    local hum = char:FindFirstChild("Humanoid")
    if not hrp or not hum then return end
    
    local isSameObject = mouseTargetInspectF()
    
    if isSameObject then
        return
    end
    
    if not inspectD then
        inspectD = true
        
        if inspectT and currentInspectS ~= 0 then
            if currentInspectS == 1 then
                currentInspectedAdorneeS = mouse.Target.Parent
                currentInspectedPartS = mouse.Target
                highlightInstance = highlight:Clone()
                highlightInstance.Adornee = mouse.Target.Parent
                highlightInstance.Parent = mouse.Target
                highlightInstance.FillColor = Color3.fromRGB(255, 255, 255)
                highlightInstance.OutlineColor = Color3.fromRGB(160, 11, 11)
            elseif currentInspectS == 2 then
                currentInspectedAdorneeS = workspace.Plots:FindFirstChild("Plot"..currentHouseInspectS)
                currentInspectedPartS = mouse.Target
                highlightInstance = highlight:Clone()
                highlightInstance.Adornee = workspace.Plots:FindFirstChild("Plot"..currentHouseInspectS)
                highlightInstance.Parent = mouse.Target
                highlightInstance.FillColor = Color3.fromRGB(255, 255, 255)
                highlightInstance.OutlineColor = Color3.fromRGB(0, 60, 180)
            elseif currentInspectS == 3 then
                currentInspectedAdorneeS = mouse.Target.Parent
                currentInspectedPartS = mouse.Target
                highlightInstance = highlight:Clone()
                highlightInstance.Adornee = mouse.Target.Parent
                highlightInstance.Parent = mouse.Target
                highlightInstance.FillColor = Color3.fromRGB(255, 255, 255)
                highlightInstance.OutlineColor = Color3.fromRGB(20, 170, 20)
            elseif currentInspectS == 4 then
                currentInspectedAdorneeS = mouse.Target.Parent
                currentInspectedPartS = mouse.Target
                highlightInstance = highlight:Clone()
                highlightInstance.Adornee = mouse.Target.Parent
                highlightInstance.Parent = mouse.Target
                highlightInstance.FillColor = Color3.fromRGB(255, 255, 255)
                highlightInstance.OutlineColor = Color3.fromRGB(180, 20, 180)
            end
        else
            clearInspection()
        end
        
        task.wait(0.1)
        inspectD = false
    end
end

local function inspectInfoF()
    local char = plr.Character
    if not char then return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    local hum = char:FindFirstChild("Humanoid")
    if not hrp or not hum then return end
    
    if not inspectInfoOnT and inspectInfoT and inspectT and currentInspectS ~= 0 and currentInspectedPartS ~= nil and currentInspectedAdorneeS ~= nil then
        inspectInfoOnT = true
        billboardInstance = billboard:Clone()
        billboardInstance.Adornee = currentInspectedAdorneeS
        billboardInstance.Parent = currentInspectedPartS

        local scrollframeC = scrollframe:Clone()
        scrollframeC.Parent = billboardInstance
        scrollframeC.Size = UDim2.new(0, 160, 0, 60)
        scrollframeC.ScrollBarImageTransparency = 1 

        local textlabelC1 = textlabel:Clone()
        textlabelC1.Parent = scrollframeC
        textlabelC1.Size = UDim2.new(0, 140, 0, 30)
        textlabelC1.Position = UDim2.new(0, 0, 0, 0)
        
        local textlabelC2 = textlabel:Clone()
        textlabelC2.Parent = scrollframeC
        textlabelC2.Size = UDim2.new(0, 140, 0, 30)
        textlabelC2.Position = UDim2.new(0, 0, 0, 30)
        
        if currentInspectS == 1 then
            local player = game.Players:FindFirstChild(currentInspectedAdorneeS.Name)
            if player then
                -- Mostra ambos os nomes: username e display name
                textlabelC1.Text = "Username: " .. player.Name
                textlabelC2.Text = "Display: " .. player.DisplayName
            else
                textlabelC1.Text = currentInspectedAdorneeS.Name
                textlabelC2.Text = ""
            end
        else
            textlabelC1.Text = currentInspectedAdorneeS.Name
            textlabelC2.Text = ""
        end
    elseif not inspectInfoT and inspectInfoOnT or not inspectT and inspectInfoOnT then
        inspectInfoOnT = false
        if billboardInstance then
            billboardInstance:Destroy()
            billboardInstance = nil
        end
    end
end

local function inspectBringF()
    local char = plr.Character
    if not char then return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    local hum = char:FindFirstChild("Humanoid")
    if not hrp or not hum then return end
    
    if inspectT and currentInspectS ~= 2 and currentInspectS ~= 4 then
        returnPosS = hrp.CFrame
        hrp.CFrame = currentInspectedAdorneeS.PrimaryPart.CFrame + Vector3.new(7, 3, 0)
        task.wait(0.15)
        
        if currentInspectS == 1 then
            local humanoidRootPart = currentInspectedAdorneeS:FindFirstChild("HumanoidRootPart")
            if humanoidRootPart then
                pcall(function()
                    rs.GrabEvents.SetNetworkOwner:FireServer(humanoidRootPart, humanoidRootPart.CFrame)
                end)
                task.wait(0.1)
                humanoidRootPart.CFrame = returnPosS
            end
        else
            local primaryPart = currentInspectedAdorneeS.PrimaryPart
            if primaryPart then
                pcall(function()
                    rs.GrabEvents.SetNetworkOwner:FireServer(primaryPart, primaryPart.CFrame)
                end)
                task.wait(0.1)
                primaryPart.CFrame = returnPosS
            end
        end
        hrp.CFrame = returnPosS
    elseif not inspectT then
        if mouse.Target and mouse.Target.Parent then
            if mouse.Target.Parent:IsDescendantOf(workspace.PlotItems) or 
               (mouse.Target.Parent.Parent and string.match(mouse.Target.Parent.Parent.Name, "SpawnedInToys")) or 
               (mouse.Target.Parent.Parent and mouse.Target.Parent.Parent:FindFirstChild("SpawningPlatform")) or 
               mouse.Target.Parent:FindFirstChildOfClass("Humanoid") then
                returnPosS = hrp.CFrame
                local mouseTargetS = mouse.Target
                hrp.CFrame = mouseTargetS.Parent.PrimaryPart.CFrame + Vector3.new(10, 3, 0)
                task.wait(0.15)
                
                if mouseTargetS.Parent:FindFirstChildOfClass("Humanoid") then
                    local humanoidRootPart = mouseTargetS.Parent:FindFirstChild("HumanoidRootPart")
                    if humanoidRootPart then
                        pcall(function()
                            rs.GrabEvents.SetNetworkOwner:FireServer(humanoidRootPart, humanoidRootPart.CFrame)
                        end)
                        task.wait(0.1)
                        humanoidRootPart.CFrame = returnPosS
                    end
                else
                    local primaryPart = mouseTargetS.Parent.PrimaryPart
                    if primaryPart then
                        pcall(function()
                            rs.GrabEvents.SetNetworkOwner:FireServer(primaryPart, primaryPart.CFrame)
                        end)
                        task.wait(0.1)
                        primaryPart.CFrame = returnPosS
                    end
                end
                hrp.CFrame = returnPosS
            end
        end
    end
end

-- FUNÇÃO ANTI-EXPLODE --
local function antiExplodeF()
    local char = plr.Character
    if not char then return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    local hum = char:FindFirstChild("Humanoid")
    if not hrp or not hum then return end
    
    workspace.ChildAdded:Connect(function(model)
        if model.Name == "Part" and char ~= nil and antiExplodeT then
            local mag = (model.Position - hrp.Position).Magnitude
            if mag <= 20 then
                hrp.Anchored = true
                task.wait(0.01)
                local rightArm = char:FindFirstChild("Right Arm")
                if rightArm and rightArm:FindFirstChild("RagdollLimbPart") then
                    while rightArm.RagdollLimbPart.CanCollide == true do task.wait(0.001) end
                end
                hrp.Anchored = false
            end
        end
    end)
end

-- FUNÇÕES ANTI-GRAB --
local function antiGrabF()
    local char = plr.Character
    if not char then return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    local hum = char:FindFirstChild("Humanoid")
    if not hrp or not hum then return end
    
    while antiGrabT and task.wait() do
        if plr:FindFirstChild("IsHeld") and plr.IsHeld.Value == true and antiGrabT == true then
            if hrp ~= nil then
                if antiGrabAnchorT then
                    hrp.Anchored = true
                    while plr.IsHeld.Value == true do 
                        pcall(function()
                            rs.CharacterEvents.Struggle:FireServer(plr)
                        end)
                        task.wait(0.001) 
                    end
                    hrp.Anchored = false
                elseif not antiGrabAnchorT then
                    while plr.IsHeld.Value == true do 
                        pcall(function()
                            rs.CharacterEvents.Struggle:FireServer(plr)
                        end)
                        task.wait(0.001) 
                    end
                end
            end
        end
    end
end

local function antiBlobF()
    workspace.DescendantAdded:Connect(function(toy)
        if toy.Name == "CreatureBlobman" and toy.Parent ~= inv and antiBlobT then
            task.wait()
            local leftDetector = toy:FindFirstChild("LeftDetector")
            local rightDetector = toy:FindFirstChild("RightDetector")
            if leftDetector then leftDetector:Destroy() end
            if rightDetector then rightDetector:Destroy() end
        end
    end)
end

-- Funções necessárias para o Auto Gucci
local function updateCurrentHouseF()
    local char = plr.Character
    if not char then return end
    
    if char.Parent == workspace then
        currentHouseS = 0
    elseif char.Parent.Name == "PlayersInPlots" then
        for _, plot in workspace.Plots:GetChildren() do
            local owners = plot.PlotSign and plot.PlotSign:FindFirstChild("ThisPlotsOwners")
            if owners then
                for _, owner in owners:GetChildren() do
                    if owner.Value == plr.Name then
                        currentHouseS = tonumber(plot.Name:match("%d+")) or 0
                        return
                    end
                end
            end
        end
    end
end

local function getBlobmanF()
    local char = plr.Character
    if not char then return end
    
    updateCurrentHouseF()
    if currentHouseS == 0 then
        if inv then return inv:FindFirstChild("CreatureBlobman") end
        return nil
    else
        local plot = workspace.PlotItems:FindFirstChild("Plot"..currentHouseS)
        if plot then
            return plot:FindFirstChild("CreatureBlobman")
        end
        return nil
    end
end

local function spawnBlobmanF()
    local char = plr.Character
    if not char then return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    local hum = char:FindFirstChild("Humanoid")
    if not hrp or not hum then return end
    
    local spawnRemote = rs:WaitForChild("MenuToys"):WaitForChild("SpawnToyRemoteFunction")
    if spawnRemote then
        pcall(function()
            spawnRemote:InvokeServer("CreatureBlobman", hrp.CFrame*CFrame.new(0,0,-5), Vector3.new(0, -15.716, 0))
        end)
        task.wait(1)
        blobmanInstanceS = getBlobmanF()
    end
end

local function destroyBlobmanF()
    local char = plr.Character
    if not char then return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    local hum = char:FindFirstChild("Humanoid")
    if not hrp or not hum then return end
    
    if blobmanInstanceS and destroyAutoGucciT then
        if currentHouseS == 0 then
            local args = {[1] = blobmanInstanceS}
            local destroyRemote = rs:FindFirstChild("MenuToys") and rs.MenuToys:FindFirstChild("DestroyToy")
            if destroyRemote then 
                pcall(function()
                    destroyRemote:FireServer(unpack(args))
                end)
            end
            blobmanInstanceS = nil
        else
            local plot = workspace.Plots:FindFirstChild("Plot"..currentHouseS)
            if plot and plot:FindFirstChild("TeslaCoil") then
                local zapPart = plot.TeslaCoil:FindFirstChild("ZapPart")
                if zapPart then
                    blobmanInstanceS.HumanoidRootPart.CFrame = zapPart.CFrame
                end
            end
            blobmanInstanceS = nil
        end
    end
end

local function ragdollLoopF()
    local char = plr.Character
    if not char then return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    local hum = char:FindFirstChild("Humanoid")
    if not hrp or not hum then return end
    
    if ragdollLoopD then return end
    ragdollLoopD = true
    
    while sitJumpT do
        if char and hrp then
            local args = {[1] = hrp, [2] = 0}
            pcall(function()
                rs:WaitForChild("CharacterEvents"):WaitForChild("RagdollRemote"):FireServer(unpack(args))
            end)
        end
        task.wait()
    end
    
    ragdollLoopD = false
end

local function sitJumpF()
    local char = plr.Character
    if not char then return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    local hum = char:FindFirstChild("Humanoid")
    if not hrp or not hum then return end
    
    local startTime = tick()
    while autoGucciT and tick()-startTime < 6 do
        if blobmanInstanceS then
            local seat = blobmanInstanceS:FindFirstChildWhichIsA("VehicleSeat")
            if seat and seat.Occupant ~= hum then 
                seat:Sit(hum) 
            end
        end
        task.wait(0.1)
        if char and hum then 
            hum:ChangeState(Enum.HumanoidStateType.Jumping)
        end
        task.wait(0.1)
    end
    
    if blobmanInstanceS then 
        destroyBlobmanF() 
    end
    autoGucciT = false
    sitJumpT = false
end

-- FUNÇÕES PARA ANCHOR GRAB
local function createBodyMovers(part, position, rotation)
    local bodyPosition = Instance.new("BodyPosition")
    local bodyGyro = Instance.new("BodyGyro")

    bodyPosition.P = 15000
    bodyPosition.D = 200
    bodyPosition.MaxForce = Vector3.new(5000000, 5000000, 5000000)
    bodyPosition.Position = position
    bodyPosition.Parent = part

    bodyGyro.P = 15000
    bodyGyro.D = 200
    bodyGyro.MaxTorque = Vector3.new(5000000, 5000000, 5000000)
    bodyGyro.CFrame = rotation
    bodyGyro.Parent = part
end

local function cleanupAnchoredParts()
    for _, part in ipairs(anchoredParts) do
        if part then
            if part:FindFirstChild("BodyPosition") then
                part.BodyPosition:Destroy()
            end
            if part:FindFirstChild("BodyGyro") then
                part.BodyGyro:Destroy()
            end
        end
    end

    for _, connection in ipairs(anchoredConnections) do
        connection:Disconnect()
    end
    
    anchoredParts = {}
    anchoredConnections = {}
end

local function anchorGrabF()
    while anchorGrabEnabled and task.wait() do
        pcall(function()
            local grabParts = workspace:FindFirstChild("GrabParts")
            if not grabParts then return end

            local grabPart = grabParts:FindFirstChild("GrabPart")
            if not grabPart then return end

            local weldConstraint = grabPart:FindFirstChild("WeldConstraint")
            if not weldConstraint or not weldConstraint.Part1 then return end

            local primaryPart = weldConstraint.Part1
            if not primaryPart then return end
            
            -- Verifica se já está ancorado
            local alreadyAnchored = false
            for _, anchoredPart in ipairs(anchoredParts) do
                if anchoredPart == primaryPart then
                    alreadyAnchored = true
                    break
                end
            end
            
            if not alreadyAnchored then
                -- Remove movers antigos
                for _, child in ipairs(primaryPart:GetChildren()) do
                    if child:IsA("BodyPosition") or child:IsA("BodyGyro") then
                        child:Destroy()
                    end
                end
                
                -- Cria novos movers
                createBodyMovers(primaryPart, primaryPart.Position, primaryPart.CFrame)
                table.insert(anchoredParts, primaryPart)
                
                OrionLib:MakeNotification({
                    Name = "Objeto Ancorado",
                    Content = "Objeto fixado com sucesso",
                    Time = 2
                })
            end
        end)
    end
end

-- FUNÇÕES DO SISTEMA BLOBMAN DO SCRIPT FORNECIDO
local function isDescendantOf(target, other)
    local currentParent = target.Parent
    while currentParent do
        if currentParent == other then
            return true
        end
        currentParent = currentParent.Parent
    end
    return false
end

local function DestroyT(toy)
    local toy = toy or inv:FindFirstChildWhichIsA("Model")
    rs.MenuToys.DestroyToy:FireServer(toy)
end

local function blobGrabPlayer(player, blobman)
    if blobalter == 1 then
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local args = {
                [1] = blobman:FindFirstChild("LeftDetector"),
                [2] = player.Character:FindFirstChild("HumanoidRootPart"),
                [3] = blobman:FindFirstChild("LeftDetector"):FindFirstChild("LeftWeld")
            }
            blobman:WaitForChild("BlobmanSeatAndOwnerScript"):WaitForChild("CreatureGrab"):FireServer(unpack(args))
            blobalter = 2
        end
    else
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local args = {
                [1] = blobman:FindFirstChild("RightDetector"),
                [2] = player.Character:FindFirstChild("HumanoidRootPart"),
                [3] = blobman:FindFirstChild("RightDetector"):FindFirstChild("RightWeld")
            }
            blobman:WaitForChild("BlobmanSeatAndOwnerScript"):WaitForChild("CreatureGrab"):FireServer(unpack(args))
            blobalter = 1
        end
    end
end

local function reloadMissile(bool)
    if bool then
        if not reloadBombCoroutine then
            reloadBombCoroutine = coroutine.create(function()
                connectionBombReload = inv.ChildAdded:Connect(function(child)
                    if child.Name == _G.ToyToLoad and child:WaitForChild("ThisToysNumber", 1) then
                        if child.ThisToysNumber.Value == (inv.ToyNumber.Value - 1) then
                            local connection2
                            connection2 = inv.ChildRemoved:Connect(function(child2)
                                if child2 == child then
                                    connection2:Disconnect()
                                end
                            end)

                            rs.GrabEvents.SetNetworkOwner:FireServer(child.Body, child.Body.CFrame)
                            local waiting = child.Body:WaitForChild("PartOwner", 0.5)
                            local connection = child.DescendantAdded:Connect(function(descendant)
                                if descendant.Name == "PartOwner" then
                                    if descendant.Value ~= plr.Name then
                                        DestroyT(child)
                                        connection:Disconnect()
                                    end
                                end
                            end)
                            game:GetService("Debris"):AddItem(connection, 60)
                            if waiting and waiting.Value == plr.Name then
                                for _, v in pairs(child:GetChildren()) do
                                    if v:IsA("BasePart") then
                                        v.CanCollide = false
                                    end
                                end
                                child:SetPrimaryPartCFrame(CFrame.new(-72.9304581, -3.96906614, -265.543732))
                                task.wait(0.2)
                                for _, v in pairs(child:GetChildren()) do
                                    if v:IsA("BasePart") then
                                        v.Anchored = true
                                    end
                                end
                                table.insert(bombList, child)
                                child.AncestryChanged:Connect(function()
                                    if not child.Parent then
                                        for i, bomb in ipairs(bombList) do
                                            if bomb == child then
                                                table.remove(bombList, i)
                                                break
                                            end
                                        end
                                    end
                                end)
                                connection2:Disconnect()
                            else
                                DestroyT(child)
                            end
                        end
                    end
                end)

                while true do
                    if plr:FindFirstChild("CanSpawnToy") and plr.CanSpawnToy.Value and #bombList < _G.MaxMissiles and plr.Character:FindFirstChild("Head") then
                        local spawnRemote = rs:WaitForChild("MenuToys"):WaitForChild("SpawnToyRemoteFunction")
                        spawnRemote:InvokeServer(_G.ToyToLoad, plr.Character.Head.CFrame or plr.Character.HumanoidRootPart.CFrame, Vector3.new(0, 0, 0))
                    end
                    task.wait()
                end
            end)
            coroutine.resume(reloadBombCoroutine)
        end
    else
        if reloadBombCoroutine then
            coroutine.close(reloadBombCoroutine)
            reloadBombCoroutine = nil
        end
        if connectionBombReload then
            connectionBombReload:Disconnect()
        end
    end
end

-- FUNÇÕES PARA SELEÇÃO DE PLAYERS
local function getPlayers()
    local players = {}
    for _, player in ipairs(game.Players:GetPlayers()) do
        if player ~= plr then
            table.insert(players, player.Name)
        end
    end
    return players
end

local function teleportToPlayer(player)
    local char = plr.Character
    if not char then return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    
    local targetChar = player.Character
    if not targetChar then return end
    local targetHrp = targetChar:FindFirstChild("HumanoidRootPart")
    if not targetHrp then return end
    
    hrp.CFrame = targetHrp.CFrame
end

-- FUNÇÕES PARA BLOBMAN TAB
local function blobmanFarmF()
    while blobmanAutoFarm and task.wait(blobmanFarmSpeed) do
        spawnBlobmanF()
        task.wait(0.5)
        
        if blobmanInstanceS then
            -- Faz o Blobman seguir você
            local char = plr.Character
            if char and char:FindFirstChild("HumanoidRootPart") then
                local humanoid = blobmanInstanceS:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    humanoid:MoveTo(char.HumanoidRootPart.Position)
                end
            end
            
            task.wait(3)
            destroyBlobmanF()
        end
    end
end

-- Configura inicialmente o sistema de teleporte
teleportConnection = setupTeleportKeybind()

-- Configura infinite jump
setupInfiniteJump()

-- Aba Antis
local Antis = Window:MakeTab({
    Name = "Antis",
    Icon = "rbxassetid://13180179055",
    PremiumOnly = false
})

-- Sistema Anti-Explode
Antis:AddToggle({
    Name = "AntiExplode",
    Default = true,
    Callback = function(Value)
        antiExplodeT = Value
        if Value then
            antiExplodeF()
            OrionLib:MakeNotification({
                Name = "Anti-Explode Ativado!",
                Content = "Proteção contra explosões ativada",
                Time = 3
            })
        else
            OrionLib:MakeNotification({
                Name = "Anti-Explode Desativado!",
                Content = "Proteção contra explosões desativada",
                Time = 3
            })
        end
    end
})

-- Sistema Anti-Grab
Antis:AddToggle({
    Name = "AntiGrab",
    Default = true,
    Callback = function(Value)
        antiGrabT = Value
        if Value then
            coroutine.wrap(antiGrabF)()
            OrionLib:MakeNotification({
                Name = "Anti-Grab Ativado!",
                Content = "Proteção contra grabs ativada",
                Time = 3
            })
        else
            OrionLib:MakeNotification({
                Name = "Anti-Grab Desativado!",
                Content = "Proteção contra grabs desativada",
                Time = 3
            })
        end
    end
})

Antis:AddToggle({
    Name = "AntiGrab Anchor",
    Default = true,
    Callback = function(Value)
        antiGrabAnchorT = Value
    end
})

Antis:AddToggle({
    Name = "AntiBlob",
    Default = false,
    Callback = function(Value)
        antiBlobT = Value
        if Value then
            antiBlobF()
            OrionLib:MakeNotification({
                Name = "Anti-Blob Ativado!",
                Content = "Proteção contra blobs ativada",
                Time = 3
            })
        else
            OrionLib:MakeNotification({
                Name = "Anti-Blob Desativado!",
                Content = "Proteção contra blobs desativada",
                Time = 3
            })
        end
    end
})

-- Botão Auto Gucci
Antis:AddButton({
    Name = "Auto Gucci ▶",
    Callback = function()
        autoGucciT = true
        spawnBlobmanF()
        task.wait(1.1)
        if not sitJumpT then
            coroutine.wrap(sitJumpF)()
            sitJumpT = true
        end
        coroutine.wrap(ragdollLoopF)()
        
        OrionLib:MakeNotification({
            Name = "Auto Gucci Ativado!",
            Content = "Executando Auto Gucci por 6 segundos...",
            Time = 3
        })
    end
})

-- Toggle para destruir automaticamente
Antis:AddToggle({
    Name = "Destroy Auto Gucci",
    Default = true,
    Callback = function(Value)
        destroyAutoGucciT = Value
    end
})
 
-- Aba Players (SEGUNDA ABA)
local PlayersTab = Window:MakeTab({
    Name = "Players",
    Icon = "rbxassetid://11984980776",
    PremiumOnly = false
})

-- Infinite Jump
PlayersTab:AddToggle({
    Name = "Infinite Jump",
    Default = false,
    Callback = function(Value)
        infJumpT = Value
        if Value then
            OrionLib:MakeNotification({
                Name = "Infinite Jump Ativado!",
                Content = "Pulo infinito ativado",
                Time = 3
            })
        else
            OrionLib:MakeNotification({
                Name = "Infinite Jump Desativado!",
                Content = "Pulo infinito desativado",
                Time = 3
            })
        end
    end
})

-- WalkSpeed
PlayersTab:AddToggle({
    Name = "WalkSpeed",
    Default = false,
    Callback = function(Value)
        walkSpeedT = Value
        updateWalkSpeedF()
        if Value then
            OrionLib:MakeNotification({
                Name = "WalkSpeed Ativado!",
                Content = "WalkSpeed: " .. walkSpeedV,
                Time = 3
            })
        else
            OrionLib:MakeNotification({
                Name = "WalkSpeed Desativado!",
                Content = "WalkSpeed padrão",
                Time = 3
            })
        end
    end
})

PlayersTab:AddSlider({
    Name = "WalkSpeed Value",
    Min = 16,
    Max = 250,
    Default = 16,
    Color = Color3.fromRGB(255,255,255),
    Increment = 1,
    ValueName = "WalkSpeed",
    Callback = function(Value)
        walkSpeedV = Value
        if walkSpeedT then
            updateWalkSpeedF()
        end
    end
})

-- NoClip
PlayersTab:AddToggle({
    Name = "NoClip",
    Default = false,
    Callback = function(Value)
        noClipT = Value
        if Value then
            updateNoClipF()
            OrionLib:MakeNotification({
                Name = "NoClip Ativado!",
                Content = "NoClip ativado",
                Time = 3
            })
        else
            OrionLib:MakeNotification({
                Name = "NoClip Desativado!",
                Content = "NoClip desativado",
                Time = 3
            })
        end
    end
})

-- Jump Power
PlayersTab:AddSlider({
    Name = "Jump Power",
    Min = 50,
    Max = 550,
    Default = 50,
    Color = Color3.fromRGB(255,255,255),
    Increment = 1,
    ValueName = "JumpPower",
    Callback = function(Value)
        jumpPowerV = Value
        if infJumpT then
            updateJumpPowerF()
        end
    end
})

-- Aba Linhas
local LinesTab = Window:MakeTab({
    Name = "Linhas",
    Icon = "rbxassetid://124620632231839",
    PremiumOnly = false
})

LinesTab:AddSection({
    Name = "Força de Arremesso"
})

LinesTab:AddSlider({
    Name = "Intensidade da Força",
    Min = 100,
    Max = 5000,
    Default = lineStrength,
    Color = Color3.fromRGB(255, 255, 255),
    Increment = 10,
    ValueName = "unidades",
    Callback = function(Value)
        lineStrength = Value
        aplicarForcaArremesso()
    end    
})

LinesTab:AddToggle({
    Name = "Ativar Sistema de Força",
    Default = false,
    Callback = function(Value)
        if Value then
            ativarSistemaForca()
        else
            desativarSistemaForca()
        end
    end
})

LinesTab:AddSection({Name = "Controle de Altura de Slides"})

LinesTab:AddSlider({
    Name = "Altura dos Slides",
    Min = 50,
    Max = 500,
    Default = Config.slideHeight,
    Color = Color3.fromRGB(255, 255, 255),
    Increment = 10,
    ValueName = "pixels",
    Callback = function(Value)
        Config.slideHeight = Value
        ajustarAlturaSlides()
    end    
})

LinesTab:AddToggle({
    Name = "Altura Automática",
    Default = Config.autoHeight,
    Callback = function(Value)
        Config.autoHeight = Value
        if Value then
            ativarAlturaAutomatica()
        end
    end
})

LinesTab:AddToggle({
    Name = "Modo Infinito",
    Default = Config.infiniteMode,
    Callback = function(Value)
        Config.infiniteMode = Value
        ajustarModoInfinito()
    end
})

LinesTab:AddButton({
    Name = "Aplicar Estilo Flexbox",
    Callback = function()
        aplicarEstiloFlexbox()
    end
})

-- Seção de utilitários
LinesTab:AddSection({Name = "Utilitários"})

LinesTab:AddColorpicker({
    Name = "Cor de Fundo",
    Default = Color3.fromRGB(204, 204, 204), -- #ccc
    Callback = function(Value)
        aplicarCorFundoSlides(Value)
    end  
})

LinesTab:AddButton({
    Name = "Resetar Configurações",
    Callback = function()
        resetarConfiguracoes()
    end
})

-- Aba Principal
local MainTab = Window:MakeTab({
    Name = "Main",
    Icon = "rbxassetid://124620632231839",
    PremiumOnly = false
})

-- Seletor de keybind para o teleporte
MainTab:AddDropdown({
    Name = "Keybind de Teleporte",
    Default = "Z",
    Options = {"Z", "Q", "R", "F", "G", "T"},
    Callback = function(Value)
        teleportKeybind = Enum.KeyCode[Value]
        OrionLib:MakeNotification({
            Name = "Keybind Alterada",
            Content = "Tecla de teleporte alterada para: " .. Value,
            Time = 3
        })
    end
})

-- Botão de teleporte normal (alternativa)
MainTab:AddButton({
    Name = "Teleporte (Clique Único)",
    Callback = function()
        local char = plr.Character
        if not char then return end
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        
        local mouse = plr:GetMouse()
        if mouse.Target then 
            hrp.CFrame = CFrame.new(mouse.Hit.X, mouse.Hit.Y + 5, mouse.Hit.Z)
        end
    end
})

--Script do bliz
MainTab:AddButton({
    Name = "Script do Bliz_T",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/BlizTBr/scripts/refs/heads/main/FTAP.lua"))()
    end
})

MainTab:AddButton({
    Name = "Fechar UI",
    Callback = function()
        OrionLib:Destroy()
    end
})

MainTab:AddButton({
    Name = "Mais Inf",
    Callback = function()
        OrionLib:MakeNotification({
            Name = "Mais Inf",
            Content = "Desative Todas as opções para evitar bugs"
        })
    end
})

-- Aba de Inspeção
local InspectTab = Window:MakeTab({
    Name = "Inspect/Bring",
    Icon = "rbxassetid://6523858394",
    PremiumOnly = false
})

-- Sistema de Inspeção com Toggle
InspectTab:AddToggle({
    Name = "Modo Inspeção",
    Default = false,
    Callback = function(Value)
        inspectT = Value
        if Value then
            inspectF()
            OrionLib:MakeNotification({
                Name = "Inspeção Ativada!",
                Content = "Aponte para objetos para inspecionar",
                Time = 3
            })
        else
            clearInspection()
            OrionLib:MakeNotification({
                Name = "Inspeção Desativada!",
                Content = "Modo de inspeção desativado",
                Time = 3
            })
        end
    end
})

InspectTab:AddToggle({
    Name = "Mostrar Info",
    Default = false,
    Callback = function(Value)
        inspectInfoT = Value
        if Value then
            inspectInfoF()
        else
            if billboardInstance then
                billboardInstance:Destroy()
                billboardInstance = nil
            end
            inspectInfoOnT = false
        end
    end
})

InspectTab:AddButton({
    Name = "Trazer Objeto",
    Callback = function()
        inspectBringF()
        OrionLib:MakeNotification({
            Name = "Objeto Trazido",
            Content = "Objeto inspecionado foi trazido para sua posição",
            Time = 3
        })
    end
})

-- Keybind para inspeção com toggle
InspectTab:AddBind({
    Name = "Keybind Inspeção (Toggle)",
    Default = Enum.KeyCode.Y,
    Hold = false,
    Callback = function()
        inspectT = not inspectT
        
        if inspectT then
            inspectF()
            OrionLib:MakeNotification({
                Name = "Inspeção Ativada!",
                Content = "Modo inspeção ativado - Aponte para objetos",
                Time = 3
            })
        else
            clearInspection()
            OrionLib:MakeNotification({
                Name = "Inspeção Desativada!",
                Content = "Modo inspeção desativado",
                Time = 3
            })
        end
    end
})

-- Keybind para limpar inspeção
InspectTab:AddBind({
    Name = "Limpar Inspeção",
    Default = Enum.KeyCode.U,
    Hold = false,
    Callback = function()
        clearInspection()
        OrionLib:MakeNotification({
            Name = "Inspeção Limpa",
            Content = "Objeto inspecionado foi desmarcado",
            Time = 2
        })
    end
})

-- NOVA SEÇÃO: SELEÇÃO DE PLAYERS
InspectTab:AddLabel("Seleção de Players")

-- Dropdown para selecionar players
local playerDropdown = InspectTab:AddDropdown({
    Name = "Selecionar Player",
    Default = "Nenhum",
    Options = {"Nenhum"},
    Callback = function(Value)
        if Value == "Nenhum" then
            selectedPlayer = nil
        else
            selectedPlayer = game.Players[Value]
        end
    end
})

-- Atualizar lista de players
local function updatePlayerList()
    local players = getPlayers()
    table.insert(players, 1, "Nenhum")
    playerDropdown:Refresh(players, true)
end

-- Botão para atualizar lista de players
InspectTab:AddButton({
    Name = "Atualizar Lista de Players",
    Callback = function()
        updatePlayerList()
        OrionLib:MakeNotification({
            Name = "Lista Atualizada",
            Content = "Lista de players atualizada",
            Time = 2
        })
    end
})

-- Botão para teleportar para o player selecionado
InspectTab:AddButton({
    Name = "Teleportar para Player",
    Callback = function()
        if selectedPlayer then
            teleportToPlayer(selectedPlayer)
            OrionLib:MakeNotification({
                Name = "Teleportado",
                Content = "Teleportado para " .. selectedPlayer.Name,
                Time = 3
            })
        else
            OrionLib:MakeNotification({
                Name = "Erro",
                Content = "Nenhum player selecionado",
                Time = 3
            })
        end
    end
})

-- Toggle para loop de teleporte
InspectTab:AddToggle({
    Name = "Loop Teleport para Player",
    Default = false,
    Callback = function(Value)
        teleportLoop = Value
        if Value then
            OrionLib:MakeNotification({
                Name = "Loop Teleport Ativado",
                Content = "Teleportando para " .. (selectedPlayer and selectedPlayer.Name or "Nenhum"),
                Time = 3
            })
            
            -- Inicia o loop de teleporte
            while teleportLoop and selectedPlayer do
                teleportToPlayer(selectedPlayer)
                task.wait(0.1)
            end
        else
            OrionLib:MakeNotification({
                Name = "Loop Teleport Desativado",
                Content = "Loop de teleporte desativado",
                Time = 3
            })
        end
    end
})

-- Botão para trazer player usando inspectBringF
InspectTab:AddButton({
    Name = "Trazer Player (InspectBring)",
    Callback = function()
        if selectedPlayer then
            -- Simula a inspeção do player para usar a função inspectBringF
            local originalInspectT = inspectT
            local originalCurrentInspectS = currentInspectS
            local originalCurrentInspectedAdorneeS = currentInspectedAdorneeS
            
            inspectT = true
            currentInspectS = 1
            currentInspectedAdorneeS = selectedPlayer.Character
            
            -- Chama a função inspectBringF
            inspectBringF()
            
            -- Restaura os valores originais
            inspectT = originalInspectT
            currentInspectS = originalCurrentInspectS
            currentInspectedAdorneeS = originalCurrentInspectedAdorneeS
            
            OrionLib:MakeNotification({
                Name = "Player Trazido",
                Content = selectedPlayer.Name .. " foi trazido para você usando InspectBring",
                Time = 3
            })
        else
            OrionLib:MakeNotification({
                Name = "Erro",
                Content = "Nenhum player selecionado",
                Time = 3
            })
        end
    end
})

-- Toggle para loop de trazer player usando inspectBringF
InspectTab:AddToggle({
    Name = "Loop Trazer Player (InspectBring)",
    Default = false,
    Callback = function(Value)
        bringLoop = Value
        if Value then
            OrionLib:MakeNotification({
                Name = "Loop Trazer Ativado",
                Content = "Trazendo " .. (selectedPlayer and selectedPlayer.Name or "Nenhum") .. " usando InspectBring",
                Time = 3
            })
            
            -- Inicia o loop de trazer player
            while bringLoop and selectedPlayer do
                -- Simula a inspeção do player para usar a função inspectBringF
                local originalInspectT = inspectT
                local originalCurrentInspectS = currentInspectS
                local originalCurrentInspectedAdorneeS = currentInspectedAdorneeS
                
                inspectT = true
                currentInspectS = 1
                currentInspectedAdorneeS = selectedPlayer.Character
                
                -- Chama a função inspectBringF
                inspectBringF()
                
                -- Restaura os valores originais
                inspectT = originalInspectT
                currentInspectS = originalCurrentInspectS
                currentInspectedAdorneeS = originalCurrentInspectedAdorneeS
                
                task.wait(0.1)
            end
        else
            OrionLib:MakeNotification({
                Name = "Loop Trazer Desativado",
                Content = "Loop de trazer desativado",
                Time = 3
            })
        end
    end
})

-- NOVA ABA: ANCHOR GRAB
local AnchorTab = Window:MakeTab({
    Name = "Anchor Grab",
    Icon = "rbxassetid://10709782497",
    PremiumOnly = false
})

AnchorTab:AddLabel("Sistema Anchor Grab - Fixa objetos ao agarrar")

-- Toggle para Anchor Grab
AnchorTab:AddToggle({
    Name = "Anchor Grab",
    Default = false,
    Callback = function(Value)
        anchorGrabEnabled = Value
        if Value then
            -- Inicia a corrotina do Anchor Grab
            coroutine.wrap(anchorGrabF)()
            OrionLib:MakeNotification({
                Name = "Anchor Grab Ativado",
                Content = "Objetos serão fixados ao agarrar",
                Time = 3
            })
        else
            -- Limpa objetos ancorados
            cleanupAnchoredParts()
            OrionLib:MakeNotification({
                Name = "Anchor Grab Desativado",
                Content = "Sistema de fixação desativado",
                Time = 3
            })
        end
    end
})

-- Keybind para Anchor Grab
AnchorTab:AddBind({
    Name = "Keybind Anchor Grab (Toggle)",
    Default = Enum.KeyCode.K,
    Hold = false,
    Callback = function()
        anchorGrabEnabled = not anchorGrabEnabled
        if anchorGrabEnabled then
            -- Inicia a corrotina do Anchor Grab
            coroutine.wrap(anchorGrabF)()
            OrionLib:MakeNotification({
                Name = "Anchor Grab Ativado",
                Content = "Tecla K - Objetos serão fixados ao agarrar",
                Time = 3
            })
        else
            -- Limpa objetos ancorados
            cleanupAnchoredParts()
            OrionLib:MakeNotification({
                Name = "Anchor Grab Desativado",
                Content = "Tecla K - Sistema de fixação desativado",
                Time = 3
            })
        end
    end
})

-- Botão para limpar objetos ancorados
AnchorTab:AddButton({
    Name = "Limpar Objetos Ancorados",
    Callback = function()
        cleanupAnchoredParts()
        OrionLib:MakeNotification({
            Name = "Objetos Limpos",
            Content = "Todos os objetos ancorados foram liberados",
            Time = 3
        })
    end
})

AnchorTab:AddLabel("Instruções:")
AnchorTab:AddLabel("1. Ative o Anchor Grab")
AnchorTab:AddLabel("2. Agarre um objeto para fixá-lo")
AnchorTab:AddLabel("3. Use a tecla K para toggle rápido")
AnchorTab:AddLabel("4. Use o botão para limpar todos")

-- NOVA ABA: BLOBMAN (COM O CÓDIGO DO SCRIPT FORNECIDO)
local BlobmanTab = Window:MakeTab({
    Name = "Blobman",
    Icon = "rbxassetid://129000779735197",
    PremiumOnly = false
})

BlobmanTab:AddLabel("Sistema Blobman Avançado")

-- Toggle para Destroy Server
BlobmanTab:AddToggle({
    Name = "Destroy server",
    Default = false,
    Callback = function(Value)
        if Value then
            -- Verifica se está montado em um Blobman
            local foundBlobman = false
            for i, v in pairs(workspace:GetDescendants()) do
                if v.Name == "CreatureBlobman" then
                    if v:FindFirstChild("VehicleSeat") and v.VehicleSeat:FindFirstChild("SeatWeld") and 
                       isDescendantOf(v.VehicleSeat.SeatWeld.Part1, plr.Character) then
                        blobman = v
                        foundBlobman = true
                        break
                    end
                end
            end

            if not foundBlobman then
                OrionLib:MakeNotification({
                    Name = "Erro",
                    Content = "Você deve estar montado em um Blobman para ativar esta função!",
                    Time = 5,
                    Image = 4483362458,
                })
                return
            end

            -- Inicia a corrotina do Destroy Server
            blobmanCoroutine = coroutine.create(function()
                while true do
                    pcall(function()
                        for i, v in pairs(game.Players:GetChildren()) do
                            if blobman and v ~= plr then
                                blobGrabPlayer(v, blobman)
                                task.wait(_G.BlobmanDelay)
                            end
                        end
                    end)
                    task.wait(0.02)
                end
            end)
            coroutine.resume(blobmanCoroutine)
            
            OrionLib:MakeNotification({
                Name = "Destroy Server Ativado",
                Content = "Sistema de destruição ativado",
                Time = 3
            })
        else
            if blobmanCoroutine then
                coroutine.close(blobmanCoroutine)
                blobmanCoroutine = nil
                blobman = nil
            end
            OrionLib:MakeNotification({
                Name = "Destroy Server Desativado",
                Content = "Sistema de destruição desativado",
                Time = 3
            })
        end
    end
})

-- Slider para velocidade do Destroy Server
BlobmanTab:AddSlider({
    Name = "Destroy server Speed",
    Min = 0.05,
    Max = 1,
    Default = 0.5,
    Color = Color3.fromRGB(255,255,255),
    Increment = 0.01,
    ValueName = "segundos",
    Callback = function(Value)
        _G.BlobmanDelay = Value
    end
})

-- Toggle para recarregar mísseis
BlobmanTab:AddToggle({
    Name = "Recarregar Mísseis",
    Default = false,
    Callback = function(Value)
        reloadMissile(Value)
        if Value then
            OrionLib:MakeNotification({
                Name = "Recarga Ativada",
                Content = "Sistema de recarga de mísseis ativado",
                Time = 3
            })
        else
            OrionLib:MakeNotification({
                Name = "Recarga Desativada",
                Content = "Sistema de recarga de mísseis desativado",
                Time = 3
            })
        end
    end
})

-- Seletor de tipo de míssil
BlobmanTab:AddDropdown({
    Name = "Tipo de Míssil",
    Default = "BombMissile",
    Options = {"BombMissile", "Bomb", "BombNuclear"},
    Callback = function(Value)
        _G.ToyToLoad = Value
        OrionLib:MakeNotification({
            Name = "Míssil Selecionado",
            Content = "Míssil definido para: " .. Value,
            Time = 3
        })
    end
})

-- Slider para quantidade máxima de mísseis
BlobmanTab:AddSlider({
    Name = "Quantidade Máxima",
    Min = 1,
    Max = 20,
    Default = 9,
    Color = Color3.fromRGB(255,255,255),
    Increment = 1,
    ValueName = "mísseis",
    Callback = function(Value)
        _G.MaxMissiles = Value
    end
})

-- Botão para spawnar Blobman
BlobmanTab:AddButton({
    Name = "Spawnar Blobman",
    Callback = function()
        spawnBlobmanF()
        if blobmanInstanceS then
            OrionLib:MakeNotification({
                Name = "Blobman Spawnado",
                Content = "Blobman foi spawnado com sucesso",
                Time = 3
            })
        else
            OrionLib:MakeNotification({
                Name = "Erro",
                Content = "Falha ao spawnar Blobman",
                Time = 3
            })
        end
    end
})

-- Botão para destruir Blobman
BlobmanTab:AddButton({
    Name = "Destruir Blobman",
    Callback = function()
        destroyBlobmanF()
        OrionLib:MakeNotification({
            Name = "Blobman Destruído",
            Content = "Blobman foi destruído com sucesso",
            Time = 3
        })
    end
})

-- Botão para Auto Gucci
BlobmanTab:AddButton({
    Name = "Auto Gucci ▶",
    Callback = function()
        autoGucciT = true
        spawnBlobmanF()
        task.wait(1.1)
        if not sitJumpT then
            coroutine.wrap(sitJumpF)()
            sitJumpT = true
        end
        coroutine.wrap(ragdollLoopF)()
        
        OrionLib:MakeNotification({
            Name = "Auto Gucci Ativado!",
            Content = "Executando Auto Gucci por 6 segundos...",
            Time = 3
        })
    end
})

-- premium
local PremiumTab = Window:MakeTab({
    Name = "Premium",
    Icon = "rbxassetid://11322089611",
    PremiumOnly = false
})

PremiumTab:AddButton({
    Name = "Open Premium",
    Callback = function()
        OrionLib:MakeNotification({
            Name = "Premium",
            Content = "Você deve clicar em get premium para obter",
            Time = 3
        })          
    end  -- FALTANDO ESTE 'end'
})  -- E ESTE '}' ESTAVA NO LUGAR ERRADO

PremiumTab:AddButton({
    Name = "Ativar Premium",
    Callback = function()
        if chavesValidas[chaveInserida] then
            premiumAtivo = true
            OrionLib:MakeNotification({
                Name = "Premium Ativado!",
                Content = "Recursos premium desbloqueados!",
                Image = "rbxassetid://4483345998",
                Time = 5
            })
            loadPremiumFeatures()
        else
            OrionLib:MakeNotification({
                Name = "Chave Inválida",
                Content = "Verifique sua chave e tente novamente.",
                Image = "rbxassetid://4483345998",
                Time = 5
            })
        end
    end
})

-- Aba de Temas
local CreditsTab = Window:MakeTab({
    Name = "Creditos",
    Icon = "rbxassetid://10910211661",
    PremiumOnly = false
})

CreditsTab:AddLabel("Criador: Pato_Soud (l3vitomol2314)")
CreditsTab:AddLabel("Testes: Caius (pepoooooooii5)")
CreditsTab:AddLabel("Hub: Bliz_T (Blizz_T)")
--CreditsTab:AddLabel("gdodf")
--CreditsTab:AddLabel("fsdfs")

-- Atualiza a lista de players inicialmente
updatePlayerList()

local configSalva = OrionLib:GetConfig()
if configSalva and configSalva.PremiumAtivo then
    premiumAtivo = true
    chaveInserida = configSalva.ChaveAtivacao or ""
    
    OrionLib:MakeNotification({
        Name = "Bem-vindo de volta!",
        Content = "Seu premium está ativo!",
        Time = 3
    })
end

-- Inicializar
OrionLib:Init()
